#!/usr/bin/env bash

# Strict Mode
set -o nounset
set -o errexit
set -o pipefail
IFS=$'\n\t'

# Current version (semver)
_VERSION="1.0.0"

# Command to run by default
HOSTS_DEFAULT_COMMAND="${HOSTS_DEFAULT_COMMAND:-host-set}"

# Path to the host file
HOSTS_PATH="${HOSTS_PATH:-/etc/hosts}"

# _die()
#
# Usage:
#   _die printf "Error message. Variable: %s\\n" "$0"
#
# Run a command and dies
function _die() {
    # Prefix die message with "cross mark (U+274C)", often displayed as a red x.
    printf "❌  "
    "${@}" 1>&2
    exit 1
}

# Options

# Contains the arguments that are not
_COMMAND_ARGV=("${0}")
_CMD=""
_AUTO_SUDO=1

while [[ ${#} -gt 0 ]]; do
    __opt="${1}"

    shift

    case "${__opt}" in
    -h | --help)
        _CMD="help"
        ;;
    --version)
        _CMD="version"
        ;;
    --no-sudo)
        _AUTO_SUDO=1
        ;;
    *)
        # The first non-option argument is assumed to be the command name.
        # All subsequent arguments are added to $_COMMAND_ARGV.
        if [[ -n "${_CMD:-}" ]]; then
            _COMMAND_ARGV+=("${__opt}")
        else
            _CMD="${__opt}"
        fi
        ;;
    esac
done

function _search_in_file() {
    local arguments=("$@")

    if [ ${#arguments[@]} -ne 2 ]; then
        _die echo "_search_in_file requires 2 parameters"
    fi

    local pattern=${arguments[0]}
    local file=${arguments[1]}

    sed -n -e "s/\\($pattern\\)/\\1/p" "$file"
}

function _replace_in_file() {
     local arguments=("$@")

    if [ ${#arguments[@]} -ne 3 ]; then
        _die echo "_search_in_file requires 3 paramesters"
    fi

    local pattern=${arguments[0]}
    local replacement_pattern=${arguments[1]}
    local file=${arguments[2]}

    sed -i -e "s/$pattern/${replacement_pattern}/" "$file"
}

# _COMMAND_ARGV minus the first parameter
_COMMAND_PARAMETERS=(${_COMMAND_ARGV[*]})
unset "_COMMAND_PARAMETERS[0]"

# Program base name
_ME=$(basename "${0}")

# Load Commands
_DEFINED_COMMANDS=()

# _load_commands()
#
# Usage:
#   _load_commands
#
# Loads all of the commands sourced in the environment.
function _load_commands() {
    local _function_list
    mapfile -t _function_list < <(declare -F)

    for __name in "${_function_list[@]}"; do
        # Each element has the format `declare -f function_name`, so set the name
        # to only the 'function_name' part of the string.
        local _function_name
        _function_name=$(printf "%s" "${__name}" | awk '{ print $3 }')

        # Do not include internal functions
        if [[ ! "${_function_name}" =~ ^_(.*) ]]; then
            _DEFINED_COMMANDS+=("${_function_name}")
        fi
    done
}

# _main()
#${#Fruits[@]}
# Usage:
#   _main
#
# The primary function for starting the program.
function _main() {
    if [[ -z "${_CMD}" ]]; then
        _CMD="${HOSTS_DEFAULT_COMMAND}"
    fi

    # Load all of the commands.
    _load_commands

    # If the command is defined, run it, otherwise return an error.
    if _contains "${_CMD}" "${_DEFINED_COMMANDS[*]:-}"; then
        # Pass all comment arguments to the program except for the first ($0).
        ${_CMD} "${_COMMAND_PARAMETERS[@]:-}"
    else
        _die printf "Unknown command: %s\\n" "${_CMD}"
    fi
}

# _contains()
#
# Usage:
#   _contains "$item" "${list[*]}"
function _contains() {
    local _test_list=(${*:2})

    for __test_element in "${_test_list[@]:-}"; do
        if [[ "${__test_element}" == "${1}" ]]; then
            return 0
        fi
    done

    return 1
}

# _verify_write_permissions
function _verify_write_permissions() {
    if ! test -w "${HOSTS_PATH}"; then
        if ((_AUTO_SUDO)); then
            sudo "${_ME}" "${_CMD}" "${_COMMAND_PARAMETERS[@]:-}"
            exit $?
        else
            _die printf "You don't have permission to perform this operation. Try again with: sudo !!\\n"
        fi
    fi
}

function _is_valid_ip() {
    if [[ "$1" =~ ^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$ ]]; then
        return 0
    elif [[ "$1" =~ ^((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(%.+)?$ ]]; then
        return 0
    fi

    return 1
}

function _is_valid_domain() {
    if [[ "$1" = *[[:space:]]* ]]; then
        return 1
    fi

    return 0
}

function _is_valid_group() {
    if [[ "$1" = *[[:space:]]* ]]; then
        return 1
    fi

    return 0
}
function _get_group() {
    local group_name="${1:-}"

    if [[ -z "${group_name}" ]]; then 
        _die printf "Group name parameter is required\n"
    elif ! _is_valid_group "${group_name}"; then
        _die printf "Group name parameter is not valid\n"
    fi

    local group_string
    
    mapfile -t group_string < <(sed -n "s/\\#group:${group_name}[[:space:]]\+\\(.*\\)$/\\1/p" "${HOSTS_PATH}")

    if [[ ${#group_string[@]} -gt 1 ]]; then
        _die printf "Group is duplicated in file%s\n" "${HOSTS_PATH}"
    elif [[ ${#group_string[@]} -eq 0 ]]; then
        echo ""
    else
        echo "${group_string[0]}"
    fi
}

function _set_group() {
    local group_name="${1:-}"

    if [[ -z "${group_name}" ]]; then 
        _die printf "Group name parameter is required\n"
    elif ! _is_valid_group "${group_name}"; then
        _die printf "Group name parameter is not valid\n"
    fi

    local existing_group
    local group="#group:${group_name}"

    for domain in "${@:2}"; do
        group="${group} ${domain}"
    done
    
    mapfile -t existing_group < <(sed -n "s/\\#group:${group_name}[[:space:]]\+\\(.*\\)$/\\1/p" "${HOSTS_PATH}")

    if [[ ${#existing_group[@]} -gt 1 ]]; then
        _die printf "Group is duplicated in file%s\n" "${HOSTS_PATH}"
    elif [[ ${#existing_group[@]} -eq 0 ]]; then
        sed -i "1 s/^/${group}\n/" "${HOSTS_PATH}"
    else
        _replace_in_file "^#group:${group_name}[[:space:]]\+.*$" "${group}" "${HOSTS_PATH}"
    fi
}

function _delete_from_file() {
    local pattern="${1:-}"
    local file="${2:-}"

    if [[ -z "${pattern}" ]]; then
        _die printf "Pattern is required\n"
    elif ! test -w "${file}"; then
        _die printf "%s is not writeable\n" "${file}"
    fi

    sed -i -e "/${pattern}/d" "${file}"
}

function _file_contains() {
    local pattern="${1:-}"
    local file="${2:-}"

    if [[ -z "${pattern}" ]]; then
        _die printf "Pattern is required\n"
    elif ! test -r "${file}"; then
        _die printf "%s is not readable\n" "${file}"
    fi

    if ! grep -e "${pattern}" "${file}"; then
        return 1
    else
        return 0
    fi
}

function _is_host_set() {
    local hostname="${1:-}"

    if ! _file_contains "^[^[:space:]#]\+[[:space:]]\+${hostname}\([[:space:]]\+\|$\)" "${HOSTS_PATH}"; then
        return 1
    else
        return 0
    fi
}

function _delete_host_entry() {
    local hostname="${1:-}"

    _delete_from_file "^[^[:space:]#]\+[[:space:]]\+${hostname}\([[:space:]]\+\|$\)" "${HOSTS_PATH}"
}

function _set_host_entry() {
    local _ip="${1:-}"
    local _hostname="${2:-}"

    if [[ -z "${_ip:-}" ]]; then
        _die printf "IP parameter is missing.\n"
    elif [[ -z "${_hostname:-}" ]]; then
        _die printf "Hostname parameter is missing.\n"
    elif ! _is_valid_ip "${_ip}"; then
        _die printf "Not a valid ip address: %s\n" "${_ip}"
    elif ! _is_valid_domain "${_hostname}"; then
        _die printf "Not a valid hostname: %s\n" "${_hostname}"
    elif grep -q -e "^[^[:space:]#]\+[[:space:]]\+${_hostname}\([[:space:]]\+.*\)\?$" "${HOSTS_PATH}"; then
        _replace_in_file "^[^[:space:]#]\+[[:space:]]\+${_hostname}\([[:space:]]\+.*\)\?$" "${_ip}\t${_hostname}" "${HOSTS_PATH}"
    else
        printf "%s\t%s\n" "${_ip}" "${_hostname}" >> "${HOSTS_PATH}"
    fi
}

declare -A __desc
# desc()
#
# Usage:
#   desc <name> <description>
#   desc --get <name>
#
# Options:
#   --get  Print the description for <name> if one has been set.
function _desc() {
    [[ -z "${1:-}" ]] && _die printf "_desc(): No command name specified.\\n"

    if [[ "${1}" == "--get" ]]; then
        [[ -z "${2:-}" ]] && _die printf "_desc(): No command name specified.\\n"

        local _name="${2:-}"
        local _desc_var="__desc[${_name}]"

        if [[ -n "${!_desc_var:-}" ]]; then
            printf "%s\\n" "${!_desc_var}"
        else
            printf "No additional information for \`%s\`\\n" "${_name}"
        fi
    else
        if [[ -n "${2:-}" ]]; then # argument is present
            read -r -d '' "__desc[${1}]" <<HEREDOC
${2}
HEREDOC

        else # no argument is present, so assume piped input
            read -r -d '' "__desc[${1}]" || true
        fi
    fi
}

# Version #####################################################################

_desc "version" <<HEREDOC
Usage:
  ${_ME} (version | --version)

Description:
  Display the current program version.

  To save you the trouble, the current version is ${_VERSION}
HEREDOC
version() {
    printf "%s\\n" "${_VERSION}"
}

# Help ########################################################################

_desc "help" <<HEREDOC
Usage:
  ${_ME} help [<command>]

Description:
  Display help information for ${_ME} or a specified command.
HEREDOC

function help() {
    if [[ -n "${1:-}" ]]; then
        _desc --get "${1}"
    else
        cat <<HEREDOC
Usage:
  ${_ME} host-set <ip> <hostname>
  ${_ME} host-rm <hostname>
  ${_ME} group-edit <group> (+ | -) <hostname 1> <hostname 2> ... <hostname n>
  ${_ME} group-rm <group>
  ${_ME} group-set <group> <ip>
  £{_ME} group-unset <group>

Options:
  --no-sudo    Do not run commands with \`sudo\` automatically.
  -h --help    Display this help information.
  --version    Display version information.

Help:
  ${_ME} help [<command>]
HEREDOC
    fi
}

# ------------------------------------------------------------------------- add

_desc "host-set" <<HEREDOC
Usage:
  ${_ME} host-set <ip> <hostname>

Description:
  Set an hostfile entry
HEREDOC

function host-set() {
    _verify_write_permissions "$@"

    local _ip="${1:-}"
    local _hostname="${2:-}"

    _set_host_entry "${_ip}" "${_hostname}"

    printf "Set entry %s to %s\n" "${_hostname}" "${_ip}"
}

_desc "host-rm" <<HEREDOC
Usage:
  ${_ME} host-rm <hostname>

Description:
  Remove an entry
HEREDOC

function host-rm() {
    _verify_write_permissions "$@"

    local _hostname="${1:-}"

    if [[ -z "${_hostname:-}" ]]; then
        _die printf "Hostname parameter is missing.\n"
    elif ! _is_valid_domain "${_hostname}"; then
        _die printf "Not a valid hostname: %s\n" "${_hostname}"
    elif ! _is_host_set "${_hostname}"; then
        _die printf "Hostname not found.\n"
    fi

    _delete_host_entry "${_hostname}"
    printf "Removed entry %s\n" "${_hostname}"
}

_desc "group-edit" <<HEREDOC
Usage:
  ${_ME} group-edit <group> (+ | -) <hostname 1> <hostname 2> ... <hostname n>

Description:
  Add or edit a group. Use the + or - modifier to add or remove entries to an existing group
HEREDOC

function group-edit() {
    _verify_write_permissions "$@"

    local group_name="${1:-}"
    local operation="${2:-}"

    if [[ -z "${group_name}" ]]; then
        _die printf "Group name is required\n"
    elif ! _is_valid_group "${group_name}"; then
        _die printf "Group name parameter is not valid\n"
    elif [[ -z "${operation}" ]]; then
        _die printf "A second parameter is required (+, - or hostname)\n"
    fi

    local current_group
    local new_group
    IFS=" "
    read -r -a current_group <<< "$(_get_group "${group_name}")"
    
    if [[ ${operation} = "-" ]]; then
        for domain in "${current_group[@]}"; do
            if ! _contains "${domain}" "${@:3}"; then
                new_group+=("${domain}")
            fi
        done
    elif [[ "${operation}" = "+" ]]; then
        for domain in "${@:3}"; do
            if ! _contains "${domain}" "${current_group[*]}"; then
                current_group+=("${domain}")
            fi
        done

        new_group=(${current_group[*]})
    else
        new_group=(${@:2})
    fi

    _set_group "${group_name}" "${new_group[*]}"

    IFS=$'\n'
    printf "Group %s content:\n\n%s\n" "${group_name}" "${new_group[*]}"
}

_desc "group-rm" <<HEREDOC
Usage:
  ${_ME} group-rm <group>

Description:
  Remove a group
HEREDOC

function group-rm() {
    _verify_write_permissions "$@"

    local group_name="${1:-}"

    if [[ -z "${group_name}" ]]; then
        _die printf "Group name is required\n"
    elif ! _is_valid_group "${group_name}"; then
        _die printf "Group name parameter is not valid\n"
    fi

    local current_group
    IFS=" "
    read -r -a current_group <<< "$(_get_group "${group_name}")"

    if [[ ${#current_group[@]} -eq 0 ]]; then
        _die printf "Group %s not found\n" "${group_name}"
    fi

    for domain in "${current_group[@]}"; do
        _delete_host_entry "${domain}"
    done

    _delete_from_file "^#group:${group_name}[[:space:]]\+.*$" "${HOSTS_PATH}"

    printf "Group %s deleted" "${group_name}\n"
}


_desc "group-set" <<HEREDOC
Usage:
  ${_ME} group-set <group> <ip>

Description:
  Set a group to an ip address
HEREDOC

function group-set() {
    _verify_write_permissions "$@"

    local group_name="${1:-}"
    local ip="${2:-}"

    if [[ -z "${group_name}" ]]; then
        _die printf "Group name is required\n"
    elif ! _is_valid_group "${group_name}"; then
        _die printf "Group name parameter is not valid\n"
    elif [[ -z "${ip}" ]]; then
        _die printf "IP parameter is required\n"
    elif ! _is_valid_ip "${ip}"; then
        _die printf "IP address is not valid\n"
    fi

    local current_group
    IFS=" "
    read -r -a current_group <<< "$(_get_group "${group_name}")"

    if [[ ${#current_group[@]} -eq 0 ]]; then
        _die printf "Group %s not found\n" "${group_name}"
    fi

    for domain in "${current_group[@]}"; do
        _set_host_entry "${ip}" "${domain}"

        printf "%s set to %s\n" "${domain}" "${ip}"
    done
}

_desc "group-unset" <<HEREDOC
Usage:
  ${_ME} group-unset <group>

Description:
  Unset a group
HEREDOC

function group-unset() {
    _verify_write_permissions "$@"

    local group_name="${1:-}"

    if [[ -z "${group_name}" ]]; then
        _die printf "Group name is required\n"
    elif ! _is_valid_group "${group_name}"; then
        _die printf "Group name parameter is not valid\n"
    fi

    local current_group
    IFS=" "
    read -r -a current_group <<< "$(_get_group "${group_name}")"

    if [[ ${#current_group[@]} -eq 0 ]]; then
        _die printf "Group %s not found\n" "${group_name}"
    fi

    for domain in "${current_group[@]}"; do
        _delete_host_entry "${domain}"

        printf "Entry %s removed\n" "${domain}"
    done
}

# Run Program
_main
